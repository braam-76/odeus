(define (nil? a) (eq a nil))

(define (foldl f init list)
  (if list
      (foldl f
             (f init (car list))
             (cdr list))
      init))

(define (foldr f init list)
  (if list
      (f (car list)
            (foldr f init (cdr list)))
      init))

(define (unary-map proc list)
  (foldr (lambda (x rest) (cons (proc x) rest))
         nil
         list))

(define (map proc . arg-lists)
  (if (car arg-lists)
      (cons (apply proc (unary-map car arg-lists))
            (apply map (cons proc
                             (unary-map cdr arg-lists))))
      nil))

(define (append . lists)
  (foldl (lambda (acc lst) (foldr cons acc lst))
         nil
         (reverse lists)))

(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))

(defmacro (cond . clauses)
  (if (nil? clauses)
      nil
      (let* ((clause (car clauses))
             (test   (car clause))
             (body   (cdr clause)))
        `(if ,test
             ,(if (nil? body)
                  test
                  (cons 'begin body))
             (cond ,@(cdr clauses))))))
