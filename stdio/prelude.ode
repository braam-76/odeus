;; Predicates
(define (nil? a) (eq a nil))
(define (not a) (nil? a))  ;; same as nil? but easier to understand in (if ...)

(define (string? a) (eq (typeof a) 'string))
(define (integer? a) (eq (typeof a) 'integer))
(define (float? a) (eq (typeof a) 'float))
(define (number? a) (or (integer? a) (float? a)))
(define (cons? a) (eq (typeof a) 'cons))
(define (atom? a) (not (cons? a)))
(define (function? a) (eq (typeof a) 'function))
(define (macro? a) (eq (typeof a) 'macro))

;; Higher order functions
(define (foldl f init list)
  (if list
      (foldl f
             (f init (car list))
             (cdr list))
      init))

(define (foldr f init list)
  (if list
      (f (car list)
         (foldr f init (cdr list)))
      init))

(define (map proc list)
  (foldr (lambda (x rest) (cons (proc x) rest))
         nil
         list))

(define (filter list predicate)
  (if (nil? list) '()
      (let ((rest (filter (cdr list) predicate)))
        (if (predicate (car list))
            (cons (car list) rest)
            rest))))

(define (compose . functions)
  (define (compose-2 f g)
    (lambda (x) (f (g x))))
  (define (id x) x)
  (foldr compose-2 id functions))

;; List operations
(define (append . lists)
  (foldl (lambda (acc lst) (foldr cons acc lst))
         nil
         (reverse lists)))

(define caar (compose car car))
(define cdar (compose cdr car))
(define cadr (compose car cdr))
(define cddr (compose cdr cdr))

(define (nth index lst)
  (cond
    ((nil? lst)       nil)
    ((nil? (cdr lst)) nil)  ; Index out of bounds
    ((= index 0)      (car lst))
    (t                (nth (- index 1) (cdr lst)))))

;; Advanced conditionals
(defmacro (cond . clauses)
  (if (nil? clauses)
      nil
      (let* ((clause (car clauses))
             (test   (car clause))
             (body   (cdr clause)))
        `(if ,test
             ,(if (nil? body)
                  test
                  (cons 'begin body))
             (cond ,@(cdr clauses))))))

;; Thread-first (->)
(defmacro (-> expr . forms)
  (define (thread expr forms)
    (if (nil? forms)
        expr
        (let* ((form (car forms))
               (op (if (cons? form) (car form) form))
               (args (if (cons? form) (cdr form) '())))
          (thread `(,op ,expr ,@args) (cdr forms)))))
  (thread expr forms))

;; Thread-last (->>)
(defmacro (->> expr . forms)
  (define (thread expr forms)
    (if (nil? forms)
        expr
        (let* ((form (car forms))
               (op (if (cons? form) (car form) form))
               (args (if (cons? form) (cdr form) '())))
          (thread `(,op ,@args ,expr) (cdr forms)))))
  (thread expr forms))
